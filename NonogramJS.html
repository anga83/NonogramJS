<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nonogramm Game</title>

    <!-- 
    Version History:
        Version 2.4 - Reworked grid generator to ensure puzzles are solvable, added experimental mobile view
        Version 2.3 - Added tool selection via buttons to sidebar, added edges auto-crossing, added highscore functionality including a menu with import/export/clear options
        Version 2.2 - Added zoom and pan functionality
        Version 2.1 - Initial Release
    -->

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5fa;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 390px;
            background-color: white;
            border-right: 2px solid #c8c8c8;
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }

        .title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-label {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .dropdown {
            position: relative;
            width: 250px;
            margin-bottom: 10px;
        }

        .dropdown-selected {
            padding: 8px 12px;
            border: 1px solid #b4b4be;
            background-color: #f0f0f5;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dropdown-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: white;
            border: 1px solid #b4b4be;
            border-top: none;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .dropdown-option {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
        }

        .dropdown-option:hover {
            background-color: #e1e1eb;
        }

        .game-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            font-size: 12px;
        }

        .instructions {
            font-size: 11px;
            line-height: 1.4;
            margin-bottom: 20px;
        }

        .tool-section {
            margin-bottom: 20px;
        }

        .tool-display {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tool-grid {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .tool-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            min-width: 60px;
        }

        .tool-item:hover {
            background-color: #f0f0f5;
        }

        .tool-item.active {
            background-color: #dae8ff;
            border: 2px solid #0050dc;
        }

        .tool-item.inactive {
            opacity: 0.6;
        }

        .tool-icon {
            width: 40px;
            height: 40px;
            border: 1px solid black;
            background-color: #e6e6e6;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 5px;
        }

        .tool-label {
            font-size: 10px;
            text-align: center;
            font-weight: bold;
        }

        .tool-item.active .tool-label {
            color: #0050dc;
        }

        .color-section {
            margin-bottom: 20px;
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }

        .color-button {
            width: 30px;
            height: 30px;
            border: 1px solid black;
            cursor: pointer;
        }

        .color-button.selected {
            border-width: 3px;
        }

        .score-section {
            padding: 10px;
            background-color: #dae8ff;
            border-radius: 5px;
            flex: 1;
            min-height: 60px; /* Einheitliche H√∂he */
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
        }

        .score-section div {
            margin: 0;
            line-height: 1.2;
            color: #0050dc;
        }

        .score-section div:first-child {
            font-size: 14px;
            font-weight: bold;
        }

        .score-section div:last-child {
            font-size: 12px;
        }


        .timer-section {
            padding: 10px;
            background-color: #e6e6e6;
            border-radius: 5px;
            flex: 1;
            min-height: 60px; /* Einheitliche H√∂he */
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
        }

        .timer-section div {
            margin: 0;
            line-height: 1.2;
        }

        .timer-section div:first-child {
            font-size: 12px;
        }

        .timer-section div:last-child {
            font-size: 14px;
            font-weight: bold;
        }

        .game-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: hidden; /* F√ºr Pan-Feature */
            position: relative;
        }

        .game-grid-container {
            position: relative;
            transition: transform 0.2s ease; /* Smooth zoom/pan transitions */
            transform-origin: center center;
        }

        .zoom-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 100;
        }

        .zoom-info.visible {
            opacity: 1;
        }

        .game-grid {
            display: grid;
            gap: 0;
            background-color: #fafaff;
            border: 2px solid #64648c;
            padding: 10px;
        }

        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid #c8c8c8;
            cursor: pointer;
            position: relative;
            background-color: white;
        }

        .cell.highlight {
            background-color: #dcf0ff;
        }

        .cell.filled {
            background-color: #323246;
        }

        .cell.crossed::before,
        .cell.crossed::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 2px;
            background-color: #dc3232;
            transform-origin: center;
        }

        .cell.crossed::before {
            transform: translate(-50%, -50%) rotate(45deg);
        }

        .cell.crossed::after {
            transform: translate(-50%, -50%) rotate(-45deg);
        }

        .cell.auto-crossed::before,
        .cell.auto-crossed::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 2px;
            background-color: black;
            transform-origin: center;
        }

        .cell.auto-crossed::before {
            transform: translate(-50%, -50%) rotate(45deg);
        }

        .cell.auto-crossed::after {
            transform: translate(-50%, -50%) rotate(-45deg);
        }

        .cell.note::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background-color: #8080c8;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .row-hints {
            position: absolute;
            right: 100%;
            top: 10px; /* Padding des Game-Grids ber√ºcksichtigen */
            height: calc(100% - 20px); /* Padding oben und unten abziehen */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            margin-right: 10px;
        }

        .col-hints {
            position: absolute;
            bottom: 100%;
            left: 10px; /* Padding des Game-Grids ber√ºcksichtigen */
            width: calc(100% - 20px); /* Padding links und rechts abziehen */
            display: flex;
            justify-content: flex-start;
            margin-bottom: 10px;
        }

        .hint {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e6e6e6;
            border-radius: 4px;
            margin: 1px;
            padding: 4px 6px;
            font-size: 11px;
            /* font-weight: bold; */
            min-width: 20px;
            text-align: center;
        }

        .hint.completed {
            background-color: #96e696;
        }

        /* Spezielle Styling f√ºr Zeilen-Hinweise */
        .row-hints .hint {
            height: 30px;
            min-width: 40px;
            max-width: 120px; /* Maximale Breite begrenzen */
            text-align: right;
            justify-content: flex-end;
            padding-right: 8px;
            white-space: nowrap; /* Verhindert Zeilenumbr√ºche */
            overflow-x: auto; /* Horizontales Scrollen bei sehr langen Hinweisen */
            overflow-y: hidden; /* Verhindert vertikales Scrollen */
            font-size: 10px; /* Etwas kleinere Schrift f√ºr mehr Platz */
        }

        /* Scrollbar f√ºr Zeilen-Hinweise verstecken */
        .row-hints .hint::-webkit-scrollbar {
            height: 2px;
        }

        .row-hints .hint::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 1px;
        }

        .row-hints .hint::-webkit-scrollbar-track {
            background-color: transparent;
        }

        /* Spezielle Styling f√ºr Spalten-Hinweise */
        .col-hints .hint {
            width: 30px;
            min-height: 40px;
            flex-direction: column;
            writing-mode: horizontal-tb; /* Normal lesbare Schrift */
            text-orientation: mixed;
            line-height: 1.1;
            padding: 4px 2px;
        }

        .result-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .result-dialog {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            border: 4px solid;
            text-align: center;
            max-width: 500px;
        }

        .result-dialog.won {
            border-color: #28b428;
        }

        .result-dialog.lost {
            border-color: #dc3232;
        }

        .result-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .result-title.won {
            color: #28b428;
        }

        .result-title.lost {
            color: #dc3232;
        }

        .score-details {
            text-align: left;
            margin-bottom: 20px;
        }

        .score-line {
            margin-bottom: 5px;
        }

        .hidden {
            display: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                width: 300px;
            }
            
            .cell {
                width: 20px;
                height: 20px;
            }

            .row-hints {
                margin-right: 3px; /* Reduziert von 5px */
                top: 5px; /* Reduziert von 10px wegen kleinerem Padding */
                height: calc(100% - 10px); /* Angepasst an kleineres Padding */
            }
            
            .col-hints {
                margin-bottom: 3px; /* Reduziert von 5px */
                left: 5px; /* Reduziert von 10px wegen kleinerem Padding */
                width: calc(100% - 10px); /* Angepasst an kleineres Padding */
            }
            
            .row-hints .hint {
                height: 25px; /* Exakt wie Zellh√∂he */
                min-width: 25px; /* Reduziert von 30px */
                max-width: 80px; /* Reduziert von 120px */
                font-size: 8px; /* Noch kleiner f√ºr bessere Passung */
                padding: 1px 3px; /* Reduziertes Padding */
                margin: 0.5px; /* Kleinere Abst√§nde */
            }
            
            .col-hints .hint {
                width: 25px; /* Exakt wie Zellbreite */
                min-height: 25px; /* Reduziert von 30px */
                font-size: 8px; /* Noch kleiner f√ºr bessere Passung */
                padding: 1px; /* Reduziertes Padding */
                margin: 0.5px; /* Kleinere Abst√§nde */
                line-height: 1.0; /* Kompaktere Zeilenh√∂he */
            }
        }

        .language-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .language-button {
            padding: 5px 10px;
            border: 1px solid #b4b4be;
            background-color: #f0f0f5;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
        }

        .language-button.active {
            background-color: #0050dc;
            color: white;
        }

        .language-button:hover {
            background-color: #e1e1eb;
        }

        .language-button.active:hover {
            background-color: #0040bc;
        }

        .highscore-section {
            margin-bottom: 15px;
            font-size: 11px;
            border: 1px solid #e0e0e0; /* Rahmen f√ºr bessere Sichtbarkeit */
            padding: 8px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }

        .highscore-section-mini {
            padding: 10px;
            background-color: #b1f7ad;
            border-radius: 5px;
            flex: 1;
            min-height: 60px; /* Einheitliche H√∂he */
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            position: relative;
        }

        .highscore-section-mini div {
            margin: 0;
            line-height: 1.2;
        }

        .highscore-section-mini strong {
            color: #0d9e05;
            font-size: 12px;
        }

        .highscore-section-mini .highscore-value {
            font-size: 14px;
            font-weight: bold;
            color: #0d9e05;
        }

        .highscore-list {
            max-height: 100px;
            overflow-y: auto;
            padding: 5px;
            background-color: white;
            border-radius: 3px;
            margin-top: 5px;
        }

        .highscore-entry {
            padding: 3px 0;
            font-size: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .highscore-entry:last-child {
            border-bottom: none;
        }

        /* Highscore Men√º */
        .highscore-menu {
            position: absolute;
            bottom: 100%; /* √ñffnet sich nach oben */
            left: 0;
            right: 0;
            background-color: white;
            border: 1px solid #b4b4be;
            border-radius: 5px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1); /* Schatten nach oben */
            z-index: 1000;
            display: none;
            margin-bottom: 8px; /* Mehr Abstand zur Highscore-Box */
            min-width: 160px;
        }

        .highscore-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 11px;
            border-bottom: 1px solid #f0f0f0;
            white-space: nowrap;
            text-align: left;
        }

        .highscore-menu-item:last-child {
            border-bottom: none;
        }

        .highscore-menu-item:hover {
            background-color: #f0f0f5;
        }

        .highscore-menu-item.danger:hover {
            background-color: #ffe6e6;
            color: #dc3232;
        }

        .version-info {
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 11px;
            color: #888;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            /* Grundlegendes Layout */
            .game-container {
                flex-direction: column;
            }
            
            .sidebar {
                display: none; /* Desktop-Sidebar verstecken */
            }
            
            /* Game Area */
            .game-area {
                padding: 10px;
                padding-bottom: 80px; /* Platz f√ºr Bottom Bar */
                height: 100vh;
                overflow: hidden;
                position: relative; /* Wichtig f√ºr Zoom-Containment */
            }
            
            /* Zoom Container Anpassung */
            .game-grid-container {
                position: relative;
                transition: transform 0.2s ease;
                transform-origin: center center;
                /* Sicherstellen dass Container im Viewport bleibt */
                max-width: 100%;
                max-height: calc(100vh - 100px); /* Platz f√ºr Bottom Bar lassen */
            }
            
            /* Spielfeld-Anpassungen */
            .cell {
                width: 25px;
                height: 25px;
                border: 0.5px solid #c8c8c8; /* D√ºnnere Rahmen */
            }
            
            .game-grid {
                gap: 0.5px; /* Kleinere Abst√§nde */
                padding: 5px;
                border: 1px solid #64648c;
            }
            
            /* Hinweise-Anpassungen */
            .row-hints {
                margin-right: 3px;
                top: 5px;
                height: calc(100% - 10px);
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                align-items: stretch;
            }
            
            .col-hints {
                margin-bottom: 3px;
                left: 5px;
                width: calc(100% - 10px);
                display: flex;
                justify-content: flex-start;
                align-items: stretch;
            }
            
            .row-hints .hint {
                height: 25px; /* Exakt wie Zellh√∂he */
                min-width: 25px;
                max-width: 80px;
                font-size: 8px;
                padding: 1px 3px;
                margin: 0.5px;
                flex: 0 0 25px; /* Feste H√∂he von 25px pro Hint */
            }
            
            .col-hints .hint {
                width: 25px; /* Exakt wie Zellbreite */
                min-height: 25px;
                font-size: 8px;
                padding: 1px;
                margin: 0.5px;
                line-height: 1.0;
                flex: 0 0 25px; /* Feste Breite von 25px pro Hint */
            }
            
            /* Instructions verstecken */
            .instructions {
                display: none;
            }
            
            /* Mobile Bottom Bar */
            .mobile-bottom-bar {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background-color: white;
                border-top: 2px solid #c8c8c8;
                padding: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                z-index: 2000; /* Erh√∂ht von 1500 */
                min-height: 60px;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            }
            
            .mobile-tools {
                display: flex;
                gap: 8px;
            }
            
            .mobile-tool-item {
                width: 40px;
                height: 40px;
                border: 1px solid #b4b4be;
                background-color: #f0f0f5;
                cursor: pointer;
                border-radius: 5px;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
                min-height: 40px;
                min-width: 40px;
                -webkit-tap-highlight-color: transparent;
            }
            
            .mobile-tool-item.active {
                background-color: #dae8ff;
                border-color: #0050dc;
                border-width: 2px;
            }
            
            .mobile-info {
                display: flex;
                flex-direction: column;
                align-items: center;
                font-size: 11px;
                min-width: 80px;
            }
            
            .mobile-size-dropdown {
                position: relative;
                font-size: 10px;
                cursor: pointer;
                padding: 4px 8px;
                border: 1px solid #b4b4be;
                border-radius: 3px;
                background-color: #f0f0f5;
                min-width: 70px;
                text-align: center;
                min-height: 44px; /* Touch-optimiert */
                -webkit-tap-highlight-color: transparent;
            }
            
            .mobile-size-options {
                position: absolute;
                bottom: 100%;
                left: 0;
                right: 0;
                background-color: white;
                border: 1px solid #b4b4be;
                border-radius: 3px;
                margin-bottom: 5px;
                display: none;
                max-height: 200px;
                overflow-y: auto;
                z-index: 2000;
            }
            
            .mobile-size-option {
                padding: 6px 8px;
                cursor: pointer;
                border-bottom: 1px solid #f0f0f0;
                font-size: 10px;
                min-height: 44px; /* Touch-optimiert */
                -webkit-tap-highlight-color: transparent;
            }
            
            .mobile-size-option:hover {
                background-color: #e1e1eb;
            }
            
            .mobile-size-option:last-child {
                border-bottom: none;
            }
            
            /* Result Dialog Anpassungen */
            .result-overlay {
                cursor: pointer; /* Zeigt an, dass geklickt werden kann */
            }
            
            .result-dialog {
                max-width: 90%;
                padding: 20px;
            }
            
            .result-title {
                font-size: 20px;
            }
            
            /* Zoom Info Position anpassen */
            .zoom-info {
                bottom: 80px; /* √úber der Bottom Bar */
                top: auto;
            }
        }

        /* Mobile Bottom Bar f√ºr Desktop verstecken */
        .mobile-bottom-bar {
            display: none;
        }

        @media (max-width: 768px) {

            /* Verhindert dass der ganze Viewport gezoomt wird */
            body {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }

            /* Mobile Bottom Bar noch sicherer fixieren */
            .mobile-bottom-bar {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background-color: white;
                border-top: 2px solid #c8c8c8;
                padding: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                z-index: 2000;
                min-height: 60px;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                /* Zus√§tzliche Sicherung f√ºr WebKit */
                -webkit-transform: translateZ(0);
                transform: translateZ(0);
            }
        }
        
    </style>
</head>
<body>
    <div class="game-container">
        <div class="sidebar">
            <div class="title">Nonogramm</div>
           
            <div class="language-buttons">
                <button class="language-button" id="langDe">DE</button>
                <button class="language-button" id="langEn">EN</button>
            </div>

            <div class="control-section">
                <div class="control-label">Spielfeldgr√∂√üe:</div>
                <div class="dropdown" id="sizeDropdown">
                    <div class="dropdown-selected" id="dropdownSelected">
                        <span>Mittel (10x10)</span>
                        <span>‚ñº</span>
                    </div>
                    <div class="dropdown-options" id="dropdownOptions">
                        <div class="dropdown-option" data-size="5,5">
                            <span>Einfach (5x5)</span>
                            <span>[1]</span>
                        </div>
                        <div class="dropdown-option" data-size="10,10">
                            <span>Mittel (10x10)</span>
                            <span>[2]</span>
                        </div>
                        <div class="dropdown-option" data-size="15,15">
                            <span>Schwer (15x15)</span>
                            <span>[3]</span>
                        </div>
                        <div class="dropdown-option" data-size="5,10">
                            <span>Rechteckig 1 (5x10)</span>
                            <span>[4]</span>
                        </div>
                        <div class="dropdown-option" data-size="10,15">
                            <span>Rechteckig 2 (10x15)</span>
                            <span>[5]</span>
                        </div>
                        <div class="dropdown-option" data-size="10,5">
                            <span>Rechteckig 3 (10x5)</span>
                            <span>[6]</span>
                        </div>
                        <div class="dropdown-option" data-size="15,10">
                            <span>Rechteckig 4 (15x10)</span>
                            <span>[7]</span>
                        </div>
                        <div class="dropdown-option" data-size="20,15">
                            <span>Rechteckig 5 (20x15)</span>
                            <span>[8]</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="game-stats">
                <div class="stat-item" id="errorDisplay">Fehler: 0/3</div>
                <div class="stat-item" id="autoCrossStatus">Auto-Durchstreichen: Ein</div>
            </div>

            <div class="instructions">
                <strong>Steuerung:</strong><br>
                T: Zwischen Stift/Durchstreichen wechseln<br>
                H/O: Notiz-Werkzeug aktivieren/deaktivieren<br>
                A: Auto-Durchstreichen ein/aus<br>
                C: Raster auf Fehler pr√ºfen<br>
                Linksklick/Ziehen: Zelle markieren<br>
                Rechtsklick: Alternative Markierung<br>
                R: Puzzle zur√ºcksetzen<br>
                N: Neues Puzzle<br>
                E: Neues Bildpuzzle
            </div>

            <div class="tool-section">
                <div class="control-label">Aktuelles Werkzeug:</div>
                <div class="tool-grid">
                    <div class="tool-item active" id="toolPen" data-tool="pen">
                        <div class="tool-icon" id="toolIconPen"></div>
                        <div class="tool-label" id="toolLabelPen">Stift</div>
                    </div>
                    <div class="tool-item inactive" id="toolCross" data-tool="cross">
                        <div class="tool-icon" id="toolIconCross"></div>
                        <div class="tool-label" id="toolLabelCross">Durchstreichen</div>
                    </div>
                    <div class="tool-item inactive" id="toolNote" data-tool="note">
                        <div class="tool-icon" id="toolIconNote"></div>
                        <div class="tool-label" id="toolLabelNote">Notiz</div>
                    </div>
                </div>
            </div>

            <div class="color-section">
                <div class="control-label">Farbw√§hler:</div>
                <div class="color-palette" id="colorPalette"></div>
                <div id="currentColorText">Aktuelle Farbe: Schwarz</div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: auto;">
                <div class="score-section">
                    <div id="pointsDisplay">Punkte: 0</div>
                    <div id="comboDisplay">Combo: x0</div>
                </div>
                <div class="timer-section">
                    <div><strong>Zeit:</strong></div>
                    <div id="timerDisplay">00:00</div>
                </div>
                <div class="highscore-section-mini" id="highscoreSection">
                    <div><strong>Highscore:</strong></div>
                    <div class="highscore-value" id="highscoreValue">0</div>
                    <div class="highscore-menu" id="highscoreMenu">
                        <div class="highscore-menu-item" id="clearHighscores">Highscore l√∂schen</div>
                        <div class="highscore-menu-item" id="exportHighscores">Highscore exportieren</div>
                        <div class="highscore-menu-item" id="importHighscores">Highscore importieren</div>
                    </div>
                </div>
            </div>

            <div class="version-info">v2.4</div>
            
        </div>

        <div class="game-area">
            <div class="zoom-info" id="zoomInfo">Zoom: 100%</div>
            <div class="game-grid-container" id="gridContainer">
                <div class="row-hints" id="rowHints"></div>
                <div class="col-hints" id="colHints"></div>
                <div class="game-grid" id="gameGrid"></div>
            </div>
        </div>
    </div>

    <div class="result-overlay hidden" id="resultOverlay">
        <div class="result-dialog" id="resultDialog">
            <div class="result-title" id="resultTitle"></div>
            <div class="score-details" id="scoreDetails"></div>
            <div id="resultSubtext"></div>
        </div>
    </div>

    <script>

        // Lokalisierung und Cookie-Management
        class LocalizationManager {
            constructor() {
                this.currentLanguage = this.detectLanguage();
                this.translations = {
                    de: {
                        title: "Nonogramm",
                        gridSize: "Spielfeldgr√∂√üe:",
                        easy: "Einfach",
                        medium: "Mittel", 
                        hard: "Schwer",
                        rectangular: "Rechteckig",
                        errors: "Fehler",
                        autoCrossOn: "Auto-Durchstreichen: Ein",
                        autoCrossOff: "Auto-Durchstreichen: Aus",
                        controls: "Steuerung:",
                        currentTool: "Aktuelles Werkzeug:",
                        colorPicker: "Farbw√§hler:",
                        currentColor: "Aktuelle Farbe",
                        points: "Punkte",
                        combo: "Combo",
                        time: "Zeit",
                        toolPen: "Stift",
                        toolCross: "Durchstreichen", 
                        toolNote: "Notiz",
                        puzzleSolved: "Puzzle gel√∂st!",
                        tooManyErrors: "Zu viele Fehler!",
                        newPuzzleHint: "Dr√ºcke N f√ºr ein neues Puzzle",
                        restartHint: "Dr√ºcke R zum neu starten oder N f√ºr ein neues Puzzle",
                        basePoints: "Basispunkte",
                        efficiencyBonus: "Effizienz-Bonus",
                        timeBonus: "Zeit-Bonus",
                        errorFreeBonus: "Fehlerfreier Bonus",
                        totalScore: "Gesamtpunktzahl",
                        newHighscore: "üéâ Neuer Rekord!",
                        highscores: "Bestenliste",
                        noHighscores: "Noch keine Rekorde",
                        highscoreMenuClear: "Highscore l√∂schen",
                        highscoreMenuExport: "Highscore exportieren", 
                        highscoreMenuImport: "Highscore importieren",
                        highscoreConfirmClear: "Alle Highscores l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden.",
                        highscoreConfirmImport: "Highscores importieren? Bestehende Daten werden √ºberschrieben.",
                        highscoreImportSuccess: "Highscores erfolgreich importiert!",
                        highscoreImportError: "Fehler beim Importieren: Ung√ºltige JSON-Datei.",
                        colors: {
                            "Schwarz": "Schwarz",
                            "Rot": "Rot", 
                            "Blau": "Blau",
                            "Gr√ºn": "Gr√ºn",
                            "Lila": "Lila",
                            "Pink": "Pink",
                            "Orange": "Orange",
                            "Hellblau": "Hellblau"
                        }
                    },
                    en: {
                        title: "Nonogram",
                        gridSize: "Grid Size:",
                        easy: "Easy",
                        medium: "Medium",
                        hard: "Hard", 
                        rectangular: "Rectangular",
                        errors: "Errors",
                        autoCrossOn: "Auto-Cross: On",
                        autoCrossOff: "Auto-Cross: Off",
                        controls: "Controls:",
                        currentTool: "Current Tool:",
                        colorPicker: "Color Picker:",
                        currentColor: "Current Color",
                        points: "Points",
                        combo: "Combo",
                        time: "Time",
                        toolPen: "Pen",
                        toolCross: "Cross",
                        toolNote: "Note",
                        puzzleSolved: "Puzzle Solved!",
                        tooManyErrors: "Too Many Errors!",
                        newPuzzleHint: "Press N for a new puzzle",
                        restartHint: "Press R to restart or N for a new puzzle",
                        basePoints: "Base Points",
                        efficiencyBonus: "Efficiency Bonus",
                        timeBonus: "Time Bonus", 
                        errorFreeBonus: "Error-Free Bonus",
                        totalScore: "Total Score",
                        newHighscore: "üéâ New Record!",
                        highscores: "Highscore",
                        noHighscores: "No records yet",
                        highscoreMenuClear: "Clear Highscores",
                        highscoreMenuExport: "Export Highscores",
                        highscoreMenuImport: "Import Highscores", 
                        highscoreConfirmClear: "Delete all highscores? This action cannot be undone.",
                        highscoreConfirmImport: "Import highscores? Existing data will be overwritten.",
                        highscoreImportSuccess: "Highscores imported successfully!",
                        highscoreImportError: "Import error: Invalid JSON file.",
                        colors: {
                            "Schwarz": "Black",
                            "Rot": "Red",
                            "Blau": "Blue", 
                            "Gr√ºn": "Green",
                            "Lila": "Purple",
                            "Pink": "Pink",
                            "Orange": "Orange",
                            "Hellblau": "Light Blue"
                        }
                    }
                };
            }

            detectLanguage() {
                // URL-Parameter pr√ºfen
                const urlParams = new URLSearchParams(window.location.search);
                const langParam = urlParams.get('lang');
                if (langParam && (langParam === 'de' || langParam === 'en')) {
                    this.setCookie('nonogram_language', langParam, 365);
                    return langParam;
                }
                
                // Cookie pr√ºfen
                const cookieLang = this.getCookie('nonogram_language');
                if (cookieLang) {
                    return cookieLang;
                }
                
                // Browser-Sprache
                const browserLang = navigator.language || navigator.userLanguage;
                return browserLang.startsWith('de') ? 'de' : 'en';
            }

            getString(key) {
                return this.translations[this.currentLanguage][key] || key;
            }

            getColorName(colorKey) {
                return this.translations[this.currentLanguage].colors[colorKey] || colorKey;
            }

            setLanguage(lang) {
                if (lang === 'de' || lang === 'en') {
                    this.currentLanguage = lang;
                    this.setCookie('nonogram_language', lang, 365);
                    // URL aktualisieren
                    const url = new URL(window.location);
                    url.searchParams.set('lang', lang);
                    window.history.replaceState({}, '', url);
                }
            }

            setCookie(name, value, days) {
                try {
                    if (typeof(Storage) !== "undefined") {
                        localStorage.setItem(name, value);
                    }
                    // Fallback zu Cookie
                    const expires = new Date();
                    expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
                    document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
                } catch (error) {
                    console.warn('Sprache konnte nicht gespeichert werden:', error);
                }
            }

            getCookie(name) {
                try {
                    if (typeof(Storage) !== "undefined") {
                        const stored = localStorage.getItem(name);
                        if (stored) return stored;
                    }
                    // Fallback zu Cookie
                    const value = `; ${document.cookie}`;
                    const parts = value.split(`; ${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
                } catch (error) {
                    console.warn('Sprache konnte nicht geladen werden:', error);
                }
                return null;
            }
        }

        class HighScoreManager {
            constructor() {
                this.storageKey = 'nonogram_highscores';
                // Bei Initialisierung alte Daten l√∂schen
                this.migrateLegacyData();
            }

            migrateLegacyData() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        const data = JSON.parse(stored);
                        // Pr√ºfen ob alte Array-Struktur vorhanden
                        let needsMigration = false;
                        for (const key in data) {
                            if (Array.isArray(data[key])) {
                                needsMigration = true;
                                break;
                            }
                        }
                        
                        if (needsMigration) {
                            console.log('Migriere alte Highscore-Daten...');
                            localStorage.removeItem(this.storageKey);
                        }
                    }
                } catch (error) {
                    console.warn('Fehler bei Migration:', error);
                    localStorage.removeItem(this.storageKey);
                }
            }

            getHighScores(gridSize, isPredefinedImage = false) {
                const allScores = this.loadFromStorage();
                const key = `${gridSize}_${isPredefinedImage ? 'predefined' : 'random'}`;
                const result = allScores[key];
                
                // Sicherheitspr√ºfung: Falls es ein Array ist, nehme den ersten Wert oder 0
                if (Array.isArray(result)) {
                    console.warn('Alte Array-Daten gefunden, wird bereinigt...');
                    return result.length > 0 ? (result[0].score || 0) : 0;
                }
                
                return typeof result === 'number' ? result : 0;
            }

            addScore(gridSize, score, time, errors, isPredefinedImage = false) {
                try {
                    const allScores = this.loadFromStorage();
                    const key = `${gridSize}_${isPredefinedImage ? 'predefined' : 'random'}`;
                    
                    const currentBest = this.getHighScores(gridSize, isPredefinedImage);
                    
                    // Nur speichern wenn neuer Score besser ist
                    if (score > currentBest) {
                        allScores[key] = score; // Direkt als Zahl speichern
                        this.saveToStorage(allScores);
                        return true; // Neuer Rekord
                    }
                    
                    return false; // Kein neuer Rekord
                } catch (error) {
                    console.warn('Highscore konnte nicht gespeichert werden:', error);
                    return false;
                }
            }

            loadFromStorage() {
                try {
                    if (typeof(Storage) === "undefined") {
                        return this.loadFromMemory();
                    }
                    
                    const stored = localStorage.getItem(this.storageKey);
                    return stored ? JSON.parse(stored) : {};
                } catch (error) {
                    console.warn('Fehler beim Laden der Highscores:', error);
                    return this.loadFromMemory();
                }
            }

            saveToStorage(scores) {
                try {
                    if (typeof(Storage) === "undefined") {
                        this.saveToMemory(scores);
                        return;
                    }
                    
                    localStorage.setItem(this.storageKey, JSON.stringify(scores));
                } catch (error) {
                    console.warn('Fehler beim Speichern der Highscores:', error);
                    this.saveToMemory(scores);
                }
            }

            loadFromMemory() {
                if (!window.nonogramHighscores) {
                    window.nonogramHighscores = {};
                }
                return window.nonogramHighscores;
            }

            saveToMemory(scores) {
                window.nonogramHighscores = scores;
            }

            // Debug-Funktion
            debugShowAllScores() {
                const allScores = this.loadFromStorage();
                console.log('Alle gespeicherten Highscores:', allScores);
                return allScores;
            }

            // Funktion zum Zur√ºcksetzen aller Highscores
            clearAllScores() {
                try {
                    if (typeof(Storage) !== "undefined") {
                        localStorage.removeItem(this.storageKey);
                    }
                    if (window.nonogramHighscores) {
                        delete window.nonogramHighscores;
                    }
                    console.log('Alle Highscores wurden gel√∂scht');
                } catch (error) {
                    console.warn('Fehler beim L√∂schen der Highscores:', error);
                }
            }
        }


        class NonogrammGame {
            constructor() {
                // Konstanten
                this.EMPTY = 0;
                this.FILLED = 1;
                this.CROSSED = 2;
                this.AUTO_CROSSED = 3;
                this.NOTE = 4;

                // Farben
                this.colorPalette = {
                    "Schwarz": "#323246",
                    "Rot": "#dc3232",
                    "Blau": "#3232dc",
                    "Gr√ºn": "#28b428",
                    "Lila": "#9632dc",
                    "Pink": "#ff69b4",
                    "Orange": "#ffa500",
                    "Hellblau": "#9696ff"
                };

                // Spielfeld-Gr√∂√üen
                this.gridSizes = {
                    "5,5": { rows: 5, cols: 5, maxErrors: 1 },
                    "10,10": { rows: 10, cols: 10, maxErrors: 3 },
                    "15,15": { rows: 15, cols: 15, maxErrors: 5 },
                    "5,10": { rows: 5, cols: 10, maxErrors: 2 },
                    "10,15": { rows: 10, cols: 15, maxErrors: 4 },
                    "10,5": { rows: 10, cols: 5, maxErrors: 2 },
                    "15,10": { rows: 15, cols: 10, maxErrors: 4 },
                    "20,15": { rows: 20, cols: 15, maxErrors: 7 }
                };

                // Spielzustand
                this.currentSize = "10,10";
                this.rows = 10;
                this.cols = 10;
                this.maxErrors = 3;
                this.grid = [];
                this.playerGrid = [];
                this.cellColors = [];
                this.rowHints = [];
                this.colHints = [];
                this.completedRows = [];
                this.completedCols = [];
                
                this.tool = this.FILLED;
                this.selectedColor = "Schwarz";
                this.autoCrossMode = true;
                this.gameWon = false;
                this.gameLost = false;
                this.errors = 0;
                this.points = 0;
                this.comboCounter = 0;
                this.correctlyFilledCells = new Set();
                
                // Timer
                this.timerRunning = false;
                this.startTime = 0;
                this.elapsedTime = 0;
                this.timerInterval = null;
                
                // Maus-Tracking
                this.isDragging = false;
                this.lastCell = null;
                this.dragValue = null;
                this.dragColor = null;

                // Zoom und Pan
                this.zoomLevel = 1.0;
                this.minZoom = 0.5;
                this.maxZoom = 3.0;
                this.zoomStep = 0.1;
                this.panX = 0;
                this.panY = 0;
                this.panStep = 50;
                this.zoomInfoTimeout = null;

                // Vordefinierte Bilder
                this.predefinedImages = {
                    "10,10": [
                        // Baum
                        [
                            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                            [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                            [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 1, 1, 1, 0, 0]
                        ],
                        // Herz
                        [
                            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                            [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                        ]
                    ]
                };
                this.currentImageIndices = { "10,10": 0 };
                this.loadedPredefinedImage = false;

                // Lokalisierung und Highscores initialisieren
                this.localization = new LocalizationManager();
                this.highScoreManager = new HighScoreManager();

                this.initializeUI();
                this.resetGame();
            }

            initializeUI() {
                this.setupDropdown();
                this.setupColorPalette();
                this.setupEventListeners();
                this.updateToolDisplay();
                this.setupLanguageButtons();
                this.setupHighscoreMenu();
                this.setupMobileUI();
                this.setupResizeHandler();
                this.updateAllTexts();
            }

            setupResizeHandler() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        // Grid neu erstellen bei Gr√∂√üen√§nderung
                        this.createGrid();
                    }, 250);
                });
            }

            setupDropdown() {
                const dropdownSelected = document.getElementById('dropdownSelected');
                const dropdownOptions = document.getElementById('dropdownOptions');
                
                dropdownSelected.addEventListener('click', () => {
                    dropdownOptions.style.display = dropdownOptions.style.display === 'block' ? 'none' : 'block';
                });

                document.addEventListener('click', (e) => {
                    if (!document.getElementById('sizeDropdown').contains(e.target)) {
                        dropdownOptions.style.display = 'none';
                    }
                });

                dropdownOptions.addEventListener('click', (e) => {
                    const option = e.target.closest('.dropdown-option');
                    if (option) {
                        const size = option.dataset.size;
                        this.changeGridSize(size);
                        dropdownSelected.querySelector('span').textContent = option.querySelector('span').textContent;
                        dropdownOptions.style.display = 'none';
                    }
                });
            }

            setupMobileUI() {
                // Mobile Tool Events
                document.getElementById('mobileToolPen').addEventListener('click', () => {
                    this.tool = this.FILLED;
                    this.updateMobileToolDisplay();
                });
                
                document.getElementById('mobileToolCross').addEventListener('click', () => {
                    this.tool = this.CROSSED;
                    this.updateMobileToolDisplay();
                });
                
                document.getElementById('mobileToolNote').addEventListener('click', () => {
                    this.tool = this.NOTE;
                    this.updateMobileToolDisplay();
                });
                
                // Mobile Size Dropdown
                const mobileSizeDropdown = document.getElementById('mobileSizeDropdown');
                const mobileSizeOptions = document.getElementById('mobileSizeOptions');
                
                mobileSizeDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                    mobileSizeOptions.style.display = mobileSizeOptions.style.display === 'block' ? 'none' : 'block';
                });
                
                document.addEventListener('click', (e) => {
                    if (!mobileSizeDropdown.contains(e.target)) {
                        mobileSizeOptions.style.display = 'none';
                    }
                });
                
                mobileSizeOptions.addEventListener('click', (e) => {
                    const option = e.target.closest('.mobile-size-option');
                    if (option) {
                        const size = option.dataset.size;
                        this.changeGridSize(size);
                        document.getElementById('mobileSizeText').textContent = size.replace(',', 'x');
                        mobileSizeOptions.style.display = 'none';
                    }
                });
                
                // Touch Events f√ºr Pinch-to-Zoom
                this.setupTouchEvents();
                
                // Result Dialog Touch Events
                this.setupResultDialogTouch();
            }

            updateMobileToolDisplay() {
                document.querySelectorAll('.mobile-tool-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                const toolType = this.tool === this.FILLED ? 'pen' : 
                                this.tool === this.CROSSED ? 'cross' : 'note';
                document.getElementById(`mobileTool${toolType.charAt(0).toUpperCase() + toolType.slice(1)}`).classList.add('active');
                
                // Desktop Tool Display auch aktualisieren
                this.updateToolDisplay();
            }

            setupTouchEvents() {
                const gameArea = document.getElementById('gridContainer');
                let initialDistance = 0;
                let initialScale = 1;
                
                gameArea.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        initialDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        initialScale = this.zoomLevel;
                    }
                }, { passive: false });
                
                gameArea.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        const scale = (currentDistance / initialDistance) * initialScale;
                        this.zoomLevel = Math.max(this.minZoom, Math.min(this.maxZoom, scale));
                        this.applyTransform();
                        this.showZoomInfo();
                    }
                }, { passive: false });
                
                // Touch End Event hinzuf√ºgen
                gameArea.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        // Reset initial values when pinch ends
                        initialDistance = 0;
                        initialScale = this.zoomLevel;
                    }
                });
            }

            setupResultDialogTouch() {
                const resultOverlay = document.getElementById('resultOverlay');
                
                resultOverlay.addEventListener('click', (e) => {
                    // Nur auf Mobile (wenn Bottom Bar sichtbar ist)
                    if (window.innerWidth <= 768) {
                        if (e.target === resultOverlay) {
                            this.hideResultDialog();
                        }
                    }
                });
                
                // Touch Event f√ºr bessere Mobile-Erfahrung
                resultOverlay.addEventListener('touchend', (e) => {
                    if (window.innerWidth <= 768) {
                        if (e.target === resultOverlay) {
                            e.preventDefault();
                            this.hideResultDialog();
                        }
                    }
                });
            }

            setupColorPalette() {
                const palette = document.getElementById('colorPalette');
                palette.innerHTML = '';
                
                Object.entries(this.colorPalette).forEach(([name, color]) => {
                    const button = document.createElement('div');
                    button.className = 'color-button';
                    button.style.backgroundColor = color;
                    button.dataset.color = name;
                    if (name === this.selectedColor) {
                        button.classList.add('selected');
                    }
                    
                    button.addEventListener('click', () => {
                        this.selectColor(name);
                    });
                    
                    palette.appendChild(button);
                });
            }

            setupEventListeners() {
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
                
                // Verhindere Kontextmen√º bei Rechtsklick
                document.addEventListener('contextmenu', (e) => e.preventDefault());

                // Tool-Auswahl Events
                this.setupToolEvents();
            }

            setupToolEvents() {
                document.getElementById('toolPen').addEventListener('click', () => {
                    this.tool = this.FILLED;
                    this.updateToolDisplay();
                });
                
                document.getElementById('toolCross').addEventListener('click', () => {
                    this.tool = this.CROSSED;
                    this.updateToolDisplay();
                });
                
                document.getElementById('toolNote').addEventListener('click', () => {
                    this.tool = this.NOTE;
                    this.updateToolDisplay();
                });
            }

            handleKeyDown(event) {
                switch(event.key) {
                    case '1': this.changeGridSize('5,5'); break;
                    case '2': this.changeGridSize('10,10'); break;
                    case '3': this.changeGridSize('15,15'); break;
                    case '4': this.changeGridSize('5,10'); break;
                    case '5': this.changeGridSize('10,15'); break;
                    case '6': this.changeGridSize('10,5'); break;
                    case '7': this.changeGridSize('15,10'); break;
                    case '8': this.changeGridSize('20,15'); break;
                    case 'r':
                    case 'R':
                        this.hideResultDialog();
                        this.resetGame();
                        break;
                    case 'n':
                    case 'N':
                        this.hideResultDialog();
                        this.resetGame();
                        break;
                    case 't':
                    case 'T':
                        this.toggleTool();
                        break;
                    case 'h':
                    case 'H':
                    case 'o':
                    case 'O':
                        this.toggleNoteTool();
                        break;
                    case 'a':
                    case 'A':
                        this.toggleAutoCross();
                        break;
                    case 'c':
                    case 'C':
                        this.checkGridForErrors();
                        break;
                    case 'e':
                    case 'E':
                        this.loadPredefinedImage();
                        break;
                    case '+':
                    case '=': // F√ºr Tastaturen ohne separaten + Key
                        this.zoomIn();
                        break;
                    case '-':
                    case '_': // F√ºr Tastaturen mit Shift + -
                        this.zoomOut();
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        this.panUp();
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        this.panDown();
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        this.panLeft();
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        this.panRight();
                        break;
                    case '0': // Reset zoom and pan
                        this.resetZoomAndPan();
                        break;
                }
            }

            changeGridSize(sizeKey) {
                this.currentSize = sizeKey;
                const size = this.gridSizes[sizeKey];
                this.rows = size.rows;
                this.cols = size.cols;
                this.maxErrors = size.maxErrors;

                // Mobile Size Text aktualisieren
                if (document.getElementById('mobileSizeText')) {
                    document.getElementById('mobileSizeText').textContent = sizeKey.replace(',', 'x');
                }

                this.resetGame();
            }

            selectColor(colorName) {
                this.selectedColor = colorName;
                
                // UI aktualisieren
                document.querySelectorAll('.color-button').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.color === colorName);
                });
                
                const colorText = this.localization.getColorName(colorName);
                document.getElementById('currentColorText').textContent = 
                    `${this.localization.getString('currentColor')}: ${colorText}`;
                
                // Pen Tool Icon Farbe aktualisieren
                const penIcon = document.getElementById('toolIconPen');
                if (penIcon) {
                    penIcon.style.backgroundColor = this.colorPalette[this.selectedColor];
                }
            }

            toggleTool() {
                if (this.tool === this.NOTE) {
                    this.tool = this.FILLED;
                } else {
                    this.tool = this.tool === this.FILLED ? this.CROSSED : this.FILLED;
                }
                this.updateToolDisplay();
            }

            toggleNoteTool() {
                this.tool = this.tool === this.NOTE ? this.FILLED : this.NOTE;
                this.updateToolDisplay();
            }

            toggleAutoCross() {
                this.autoCrossMode = !this.autoCrossMode;
                document.getElementById('autoCrossStatus').textContent = 
                    this.autoCrossMode ? this.localization.getString('autoCrossOn') : this.localization.getString('autoCrossOff');
                
                if (this.autoCrossMode) {
                    for (let row = 0; row < this.rows; row++) {
                        this.checkAndAutocrossRow(row);
                    }
                    for (let col = 0; col < this.cols; col++) {
                        this.checkAndAutocrossCol(col);
                    }
                }

                this.checkAndAutocrossEdges();
            }

            updateToolDisplay() {
                // Pen Tool Icon
                const penIcon = document.getElementById('toolIconPen');
                penIcon.innerHTML = '';
                penIcon.style.backgroundColor = this.colorPalette[this.selectedColor];
                
                // Cross Tool Icon
                const crossIcon = document.getElementById('toolIconCross');
                crossIcon.innerHTML = '';
                crossIcon.style.backgroundColor = '#e6e6e6';
                const cross1 = document.createElement('div');
                const cross2 = document.createElement('div');
                cross1.style.cssText = 'position: absolute; width: 20px; height: 2px; background: #dc3232; transform: rotate(45deg);';
                cross2.style.cssText = 'position: absolute; width: 20px; height: 2px; background: #dc3232; transform: rotate(-45deg);';
                crossIcon.appendChild(cross1);
                crossIcon.appendChild(cross2);
                
                // Note Tool Icon
                const noteIcon = document.getElementById('toolIconNote');
                noteIcon.innerHTML = '';
                noteIcon.style.backgroundColor = '#e6e6e6';
                const note = document.createElement('div');
                note.style.cssText = 'width: 8px; height: 8px; background: #8080c8; border-radius: 50%;';
                noteIcon.appendChild(note);
                
                // Tool Labels aktualisieren
                document.getElementById('toolLabelPen').textContent = this.localization.getString('toolPen');
                document.getElementById('toolLabelCross').textContent = this.localization.getString('toolCross');
                document.getElementById('toolLabelNote').textContent = this.localization.getString('toolNote');
                
                // Aktives Tool markieren
                document.querySelectorAll('.tool-item').forEach(item => {
                    item.classList.remove('active', 'inactive');
                    
                    const toolType = item.dataset.tool;
                    if ((this.tool === this.FILLED && toolType === 'pen') ||
                        (this.tool === this.CROSSED && toolType === 'cross') ||
                        (this.tool === this.NOTE && toolType === 'note')) {
                        item.classList.add('active');
                    } else {
                        item.classList.add('inactive');
                    }
                });
            }


            resetGame() {
                this.grid = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.playerGrid = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.cellColors = Array(this.rows).fill().map(() => Array(this.cols).fill(this.colorPalette[this.selectedColor]));
                
                this.generatePuzzle();
                
                this.completedRows = Array(this.rows).fill(false);
                this.completedCols = Array(this.cols).fill(false);
                
                this.gameWon = false;
                this.gameLost = false;
                this.errors = 0;
                this.points = 0;
                this.comboCounter = 0;
                this.correctlyFilledCells.clear();
                this.loadedPredefinedImage = false;
                
                this.stopTimer();
                this.resetTimer();
                
                this.isDragging = false;
                this.lastCell = null;
                this.dragValue = null;
                
                this.createGrid();
                this.updateUI();
                this.updateHighScoreDisplay();
                this.hideResultDialog();
                this.resetZoomAndPan();
            }

            generatePuzzle() {
                // Gr√∂√üenabh√§ngige Parameter
                const totalCells = this.rows * this.cols;
                let targetFillRatio, minBlockSize, maxBlockSize, blockCount;
                
                // Angepasste Parameter basierend auf Gridgr√∂√üe
                if (totalCells <= 25) { // 5x5
                    targetFillRatio = 0.40; // Erh√∂ht von 0.35
                    minBlockSize = 2;
                    maxBlockSize = 4;
                    blockCount = Math.floor(totalCells * 0.2); // Erh√∂ht von 0.15
                } else if (totalCells <= 100) { // 10x10 und √§hnliche
                    targetFillRatio = 0.45; // Erh√∂ht von 0.40
                    minBlockSize = 2; // Reduziert von 3
                    maxBlockSize = 5; // Reduziert von 6
                    blockCount = Math.floor(totalCells * 0.15); // Erh√∂ht von 0.12
                } else if (totalCells <= 225) { // 15x15 und √§hnliche
                    targetFillRatio = 0.50; // Erh√∂ht von 0.45
                    minBlockSize = 3; // Reduziert von 4
                    maxBlockSize = 7; // Reduziert von 8
                    blockCount = Math.floor(totalCells * 0.12); // Erh√∂ht von 0.10
                } else { // 20x15 und gr√∂√üere
                    targetFillRatio = 0.55; // Erh√∂ht von 0.50
                    minBlockSize = 4; // Reduziert von 5
                    maxBlockSize = 8; // Reduziert von 10
                    blockCount = Math.floor(totalCells * 0.10); // Erh√∂ht von 0.08
                }
                
                // Grid zur√ºcksetzen
                this.grid = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                
                // Zusammenh√§ngende Bl√∂cke generieren
                for (let i = 0; i < blockCount; i++) {
                    this.generateConnectedBlock(minBlockSize, maxBlockSize);
                }
                
                // Falls zu wenig gef√ºllt, einzelne Zellen hinzuf√ºgen
                const currentFillRatio = this.getCurrentFillRatio();
                if (currentFillRatio < targetFillRatio * 0.7) { // Reduziert von 0.8
                    this.addRandomCells(targetFillRatio);
                }
                
                // Puzzle-Validierung und Hinweise berechnen
                this.calculateHints();
                
                // Einfachere L√∂sbarkeits-Pr√ºfung (maximal 3 Versuche)
                let attempts = 0;
                while (!this.isLikelySolvable() && attempts < 3) {
                    console.log(`Puzzle-Versuch ${attempts + 1} nicht optimal, versuche erneut...`);
                    
                    // Grid zur√ºcksetzen und neu generieren
                    this.grid = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                    
                    for (let i = 0; i < blockCount; i++) {
                        this.generateConnectedBlock(minBlockSize, maxBlockSize);
                    }
                    
                    const currentFillRatio = this.getCurrentFillRatio();
                    if (currentFillRatio < targetFillRatio * 0.7) {
                        this.addRandomCells(targetFillRatio);
                    }
                    
                    this.calculateHints();
                    attempts++;
                }
                
                // Falls nach 3 Versuchen immer noch nicht optimal, verwende das letzte Ergebnis
                if (attempts >= 3) {
                    console.log('Verwende aktuelles Puzzle trotz Komplexit√§t');
                }
            }

            generateConnectedBlock(minSize, maxSize) {
                const blockSize = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
                
                // Zuf√§lligen Startpunkt w√§hlen
                let startRow = Math.floor(Math.random() * this.rows);
                let startCol = Math.floor(Math.random() * this.cols);
                
                // Versuche mehrere Startpunkte falls der erste nicht geeignet ist
                for (let attempts = 0; attempts < 20; attempts++) { // Erh√∂ht von 10
                    if (this.grid[startRow][startCol] === 0) {
                        break;
                    }
                    startRow = Math.floor(Math.random() * this.rows);
                    startCol = Math.floor(Math.random() * this.cols);
                }
                
                // Einfachere Block-Generierung als Fallback
                const shapes = ['rectangle', 'line'];
                const shape = shapes[Math.floor(Math.random() * shapes.length)];
                
                switch (shape) {
                    case 'rectangle':
                        this.generateRectangularBlock(startRow, startCol, blockSize);
                        break;
                    case 'line':
                        this.generateLineBlock(startRow, startCol, blockSize);
                        break;
                    default:
                        // Fallback: Einfache rechteckige Form
                        this.generateRectangularBlock(startRow, startCol, blockSize);
                        break;
                }
            }

            generateRectangularBlock(startRow, startCol, targetSize) {
                // Rechteckige Bl√∂cke f√ºr bessere L√∂sbarkeit
                const maxWidth = Math.min(this.cols - startCol, Math.ceil(Math.sqrt(targetSize * 1.5)));
                const maxHeight = Math.min(this.rows - startRow, Math.ceil(targetSize / maxWidth));
                
                const width = Math.max(1, Math.min(maxWidth, Math.floor(Math.random() * 4) + 2));
                const height = Math.max(1, Math.min(maxHeight, Math.ceil(targetSize / width)));
                
                for (let r = startRow; r < Math.min(startRow + height, this.rows); r++) {
                    for (let c = startCol; c < Math.min(startCol + width, this.cols); c++) {
                        if (this.grid[r][c] === 0) {
                            this.grid[r][c] = 1;
                        }
                    }
                }
            }

            generateLineBlock(startRow, startCol, targetSize) {
                // Horizontale oder vertikale Linien
                const isHorizontal = Math.random() < 0.5;
                
                if (isHorizontal) {
                    const maxLength = Math.min(this.cols - startCol, targetSize);
                    for (let i = 0; i < maxLength; i++) {
                        if (startCol + i < this.cols && this.grid[startRow][startCol + i] === 0) {
                            this.grid[startRow][startCol + i] = 1;
                        }
                    }
                } else {
                    const maxLength = Math.min(this.rows - startRow, targetSize);
                    for (let i = 0; i < maxLength; i++) {
                        if (startRow + i < this.rows && this.grid[startRow + i][startCol] === 0) {
                            this.grid[startRow + i][startCol] = 1;
                        }
                    }
                }
            }

            generateLShapeBlock(startRow, startCol, targetSize) {
                // L-f√∂rmige Bl√∂cke f√ºr interessante Muster
                const armLength = Math.floor(targetSize / 2);
                
                // Horizontaler Arm
                const hLength = Math.min(this.cols - startCol, armLength);
                for (let i = 0; i < hLength; i++) {
                    if (startCol + i < this.cols && this.grid[startRow][startCol + i] === 0) {
                        this.grid[startRow][startCol + i] = 1;
                    }
                }
                
                // Vertikaler Arm
                const vLength = Math.min(this.rows - startRow, armLength);
                for (let i = 1; i < vLength; i++) {
                    if (startRow + i < this.rows && this.grid[startRow + i][startCol] === 0) {
                        this.grid[startRow + i][startCol] = 1;
                    }
                }
            }

            addRandomCells(targetFillRatio) {
                const targetCells = Math.floor(this.rows * this.cols * targetFillRatio);
                const currentCells = this.getCurrentFilledCells();
                const cellsToAdd = Math.max(0, targetCells - currentCells);
                
                let added = 0;
                let attempts = 0;
                
                while (added < cellsToAdd && attempts < cellsToAdd * 3) {
                    const row = Math.floor(Math.random() * this.rows);
                    const col = Math.floor(Math.random() * this.cols);
                    
                    if (this.grid[row][col] === 0) {
                        this.grid[row][col] = 1;
                        added++;
                    }
                    attempts++;
                }
            }

            getCurrentFillRatio() {
                return this.getCurrentFilledCells() / (this.rows * this.cols);
            }

            getCurrentFilledCells() {
                let count = 0;
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (this.grid[row][col] === 1) {
                            count++;
                        }
                    }
                }
                return count;
            }

            isLikelySolvable() {
                // Vereinfachte L√∂sbarkeits-Pr√ºfung
                
                // 1. Pr√ºfe grundlegende Hint-Validit√§t
                for (let row = 0; row < this.rows; row++) {
                    const totalHintSum = this.rowHints[row].reduce((sum, hint) => sum + hint, 0);
                    const minSpaces = Math.max(0, this.rowHints[row].length - 1);
                    if (totalHintSum + minSpaces > this.cols) {
                        return false; // Hinweise passen nicht in die Zeile
                    }
                }
                
                for (let col = 0; col < this.cols; col++) {
                    const totalHintSum = this.colHints[col].reduce((sum, hint) => sum + hint, 0);
                    const minSpaces = Math.max(0, this.colHints[col].length - 1);
                    if (totalHintSum + minSpaces > this.rows) {
                        return false; // Hinweise passen nicht in die Spalte
                    }
                }
                
                // 2. Pr√ºfe auf zu viele komplexe Muster (lockerer als vorher)
                const complexity = this.calculatePatternComplexity();
                const maxComplexity = Math.max(20, (this.rows + this.cols) * 1.5); // Lockerer Grenzwert
                
                return complexity <= maxComplexity;
            }

            calculatePatternComplexity() {
                let complexity = 0;
                
                // Z√§hle nur Bl√∂cke mit mehr als 1 Hint (leere Zeilen/Spalten ignorieren)
                for (let row = 0; row < this.rows; row++) {
                    if (this.rowHints[row].length > 1 || this.rowHints[row][0] > 0) {
                        complexity += this.rowHints[row].length;
                    }
                }
                
                for (let col = 0; col < this.cols; col++) {
                    if (this.colHints[col].length > 1 || this.colHints[col][0] > 0) {
                        complexity += this.colHints[col].length;
                    }
                }
                
                return complexity;
            }

            loadPredefinedImage() {
                if (!this.predefinedImages[this.currentSize]) {
                    console.log(`Keine vordefinierten Bilder f√ºr ${this.currentSize} verf√ºgbar`);
                    return;
                }
                
                this.loadedPredefinedImage = true;
                const images = this.predefinedImages[this.currentSize];
                const currentIndex = this.currentImageIndices[this.currentSize] || 0;
                
                this.grid = images[currentIndex].map(row => [...row]);
                this.playerGrid = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.cellColors = Array(this.rows).fill().map(() => Array(this.cols).fill(this.colorPalette[this.selectedColor]));
                
                this.calculateHints();
                
                this.completedRows = Array(this.rows).fill(false);
                this.completedCols = Array(this.cols).fill(false);
                this.gameWon = false;
                this.gameLost = false;
                this.errors = 0;
                this.points = 0;
                this.comboCounter = 0;
                this.correctlyFilledCells.clear();
                
                this.currentImageIndices[this.currentSize] = (currentIndex + 1) % images.length;
                
                this.createGrid();
                this.updateUI();
                this.updateHighScoreDisplay(); // Hier hinzuf√ºgen
            }

            calculateHints() {
                this.rowHints = this.grid.map(row => this.calculateLineHints(row));
                this.colHints = [];
                for (let col = 0; col < this.cols; col++) {
                    const colData = this.grid.map(row => row[col]);
                    this.colHints.push(this.calculateLineHints(colData));
                }
            }

            calculateLineHints(line) {
                const hints = [];
                let count = 0;
                
                for (const cell of line) {
                    if (cell === 1) {
                        count++;
                    } else if (count > 0) {
                        hints.push(count);
                        count = 0;
                    }
                }
                
                if (count > 0) {
                    hints.push(count);
                }
                
                return hints.length > 0 ? hints : [0];
            }

            createGrid() {
                const gridContainer = document.getElementById('gridContainer');
                const gameGrid = document.getElementById('gameGrid');
                const rowHintsContainer = document.getElementById('rowHints');
                const colHintsContainer = document.getElementById('colHints');

                // Mobile-spezifische Zellgr√∂√üe ermitteln
                const isMobile = window.innerWidth <= 768;
                const cellSize = isMobile ? 25 : 30; // Pixel-Werte als Zahlen
                const cellGap = isMobile ? 0.5 : 0; // Gap zwischen Zellen
                const gridPadding = isMobile ? 5 : 10; // Grid Padding
                
                // Grid-Template setzen mit korrekter Gr√∂√üe
                gameGrid.style.gridTemplateColumns = `repeat(${this.cols}, ${cellSize}px)`;
                gameGrid.style.gridTemplateRows = `repeat(${this.rows}, ${cellSize}px)`;
                gameGrid.style.gap = `${cellGap}px`;
                gameGrid.style.padding = `${gridPadding}px`;
                
                // Zellen erstellen
                gameGrid.innerHTML = '';
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Highlight-Pattern f√ºr bessere Lesbarkeit
                        if (Math.floor(row / 5) % 2 !== Math.floor(col / 5) % 2) {
                            cell.classList.add('highlight');
                        }
                        
                        this.setupCellEvents(cell);
                        gameGrid.appendChild(cell);
                    }
                }
                
                // Zeilen-Hinweise mit exakter Gr√∂√üenanpassung
                rowHintsContainer.innerHTML = '';
                const totalRowHeight = (this.rows * cellSize) + ((this.rows - 1) * cellGap);
                rowHintsContainer.style.height = `${totalRowHeight}px`;
                rowHintsContainer.style.top = `${gridPadding}px`;
                rowHintsContainer.style.marginRight = isMobile ? '3px' : '10px';
                
                for (let row = 0; row < this.rows; row++) {
                    const hintDiv = document.createElement('div');
                    hintDiv.className = 'hint';
                    hintDiv.textContent = this.rowHints[row].join(' ');
                    hintDiv.dataset.row = row;
                    
                    // Exakte Gr√∂√üenanpassung f√ºr Mobile
                    hintDiv.style.height = `${cellSize}px`;
                    hintDiv.style.minWidth = isMobile ? '25px' : '40px';
                    hintDiv.style.maxWidth = isMobile ? '80px' : '120px';
                    hintDiv.style.fontSize = isMobile ? '8px' : '10px';
                    hintDiv.style.padding = isMobile ? '1px 3px' : '4px 6px';
                    hintDiv.style.margin = isMobile ? '0.25px' : '1px';
                    hintDiv.style.lineHeight = isMobile ? '1.0' : '1.1';
                    
                    rowHintsContainer.appendChild(hintDiv);
                }
                
                // Spalten-Hinweise mit exakter Gr√∂√üenanpassung
                colHintsContainer.innerHTML = '';
                const totalColWidth = (this.cols * cellSize) + ((this.cols - 1) * cellGap);
                colHintsContainer.style.width = `${totalColWidth}px`;
                colHintsContainer.style.left = `${gridPadding}px`;
                colHintsContainer.style.marginBottom = isMobile ? '3px' : '10px';
                
                for (let col = 0; col < this.cols; col++) {
                    const hintDiv = document.createElement('div');
                    hintDiv.className = 'hint';
                    hintDiv.innerHTML = this.colHints[col].join('<br>');
                    hintDiv.dataset.col = col;
                    
                    // Exakte Gr√∂√üenanpassung f√ºr Mobile
                    hintDiv.style.width = `${cellSize}px`;
                    hintDiv.style.minHeight = isMobile ? '25px' : '40px';
                    hintDiv.style.fontSize = isMobile ? '8px' : '11px';
                    hintDiv.style.padding = isMobile ? '1px' : '4px 2px';
                    hintDiv.style.margin = isMobile ? '0.25px' : '1px';
                    hintDiv.style.lineHeight = isMobile ? '1.0' : '1.1';
                    
                    colHintsContainer.appendChild(hintDiv);
                }
            }

            setupCellEvents(cell) {
                cell.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (this.gameWon || this.gameLost) return;
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    this.isDragging = true;
                    this.lastCell = { row, col };
                    
                    if (e.button === 0) { // Linksklick
                        this.handleCellClick(row, col, this.tool);
                    } else if (e.button === 2) { // Rechtsklick
                        const altTool = this.tool === this.NOTE ? this.NOTE : 
                                    (this.tool === this.FILLED ? this.CROSSED : this.FILLED);
                        this.handleCellClick(row, col, altTool);
                    }
                });
                
                cell.addEventListener('mouseenter', (e) => {
                    if (!this.isDragging || this.gameWon || this.gameLost) return;
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if (this.lastCell.row !== row || this.lastCell.col !== col) {
                        this.lastCell = { row, col };
                        
                        if (this.dragValue === this.FILLED && this.playerGrid[row][col] === this.FILLED) {
                            return; // Bereits ausgef√ºllte Zellen beim Ziehen nicht √§ndern
                        }
                        
                        this.markCell(row, col, this.dragValue);
                    }
                });
                
                // Mouseup Event auf jeder Zelle hinzuf√ºgen
                cell.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.isDragging = false;
                    this.lastCell = null;
                    this.dragValue = null;
                });
                
                // Mouseleave Event hinzuf√ºgen f√ºr zus√§tzliche Sicherheit
                cell.addEventListener('mouseleave', (e) => {
                    // Wenn die Maus die Zelle verl√§sst und nicht gedraggt wird, sicherheitshalber stoppen
                    if (!this.isDragging) {
                        this.lastCell = null;
                        this.dragValue = null;
                    }
                });
            }

            handleCellClick(row, col, tool) {
                const currentValue = this.playerGrid[row][col];
                
                if (tool === this.FILLED) {
                    this.dragValue = currentValue === this.FILLED ? this.EMPTY : this.FILLED;
                    this.dragColor = this.colorPalette[this.selectedColor];
                } else if (tool === this.CROSSED) {
                    this.dragValue = currentValue === this.CROSSED ? this.EMPTY : this.CROSSED;
                } else if (tool === this.NOTE) {
                    this.dragValue = currentValue === this.NOTE ? this.EMPTY : this.NOTE;
                }
                
                this.markCell(row, col, this.dragValue);
            }

            markCell(row, col, value) {
                // Timer starten wenn erste Zelle markiert wird
                if (!this.timerRunning && value === this.FILLED) {
                    this.startTimer();
                }
                
                const oldValue = this.playerGrid[row][col];
                const cellPosition = `${row},${col}`;
                
                // Schutz vor √Ñnderungen in vollst√§ndig gel√∂sten Zeilen/Spalten
                if (this.autoCrossMode && value !== this.NOTE) {
                    if (this.completedRows[row] || this.completedCols[col]) {
                        return;
                    }
                }
                
                // Schutz vor ung√ºltigen √Ñnderungen
                if ((value === this.CROSSED && oldValue === this.FILLED) || 
                    oldValue === this.AUTO_CROSSED ||
                    (value === this.FILLED && (oldValue === this.CROSSED || oldValue === this.AUTO_CROSSED))) {
                    if (value !== this.NOTE) return;
                }
                
                // Toggle-Verhalten
                if (oldValue === value) {
                    this.playerGrid[row][col] = this.EMPTY;
                } else {
                    if (value === this.FILLED && oldValue !== this.FILLED) {
                        this.cellColors[row][col] = this.colorPalette[this.selectedColor];
                        
                        // Punkte-System
                        if (this.grid[row][col] === this.FILLED && !this.correctlyFilledCells.has(cellPosition)) {
                            this.correctlyFilledCells.add(cellPosition);
                            this.comboCounter++;
                            this.points += 10 * this.comboCounter;
                        } else if (this.grid[row][col] !== this.FILLED) {
                            this.comboCounter = 0;
                        }
                    }
                    
                    this.playerGrid[row][col] = value;
                }
                
                // Fehlerpr√ºfung nur beim Ausf√ºllen
                if (value === this.FILLED && oldValue !== this.FILLED) {
                    if (this.grid[row][col] !== this.FILLED) {
                        this.errors++;
                        this.comboCounter = 0;
                        this.playerGrid[row][col] = this.AUTO_CROSSED;
                        
                        if (this.errors > this.maxErrors) {
                            this.gameLost = true;
                            this.stopTimer();
                            this.showResultDialog();
                        }
                        
                        this.updateCellDisplay(row, col);
                        this.updateUI();
                        return;
                    }
                }
                
                this.updateCellDisplay(row, col);
                
                // Auto-Cross pr√ºfen
                if (this.autoCrossMode && value !== this.NOTE) {
                    this.checkAndAutocrossRow(row);
                    this.checkAndAutocrossCol(col);
                    this.checkAndAutocrossEdges();
                }
                
                this.checkWin();
                this.updateUI();
            }

            updateCellDisplay(row, col) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                const value = this.playerGrid[row][col];
                
                // Alle Klassen entfernen
                cell.classList.remove('filled', 'crossed', 'auto-crossed', 'note');
                cell.style.backgroundColor = '';
                
                if (value === this.FILLED) {
                    cell.classList.add('filled');
                    cell.style.backgroundColor = this.cellColors[row][col];
                } else if (value === this.CROSSED) {
                    cell.classList.add('crossed');
                } else if (value === this.AUTO_CROSSED) {
                    cell.classList.add('auto-crossed');
                } else if (value === this.NOTE) {
                    cell.classList.add('note');
                }
            }

            checkAndAutocrossRow(row) {
                let rowComplete = true;
                
                for (let col = 0; col < this.cols; col++) {
                    const currentValue = this.playerGrid[row][col] === this.NOTE ? this.EMPTY : this.playerGrid[row][col];
                    
                    if (this.grid[row][col] === this.FILLED && currentValue !== this.FILLED) {
                        rowComplete = false;
                        break;
                    }
                    if (this.grid[row][col] !== this.FILLED && currentValue === this.FILLED) {
                        rowComplete = false;
                        break;
                    }
                }
                
                if (rowComplete && !this.completedRows[row]) {
                    this.completedRows[row] = true;
                    
                    for (let col = 0; col < this.cols; col++) {
                        if (this.grid[row][col] !== this.FILLED && 
                            (this.playerGrid[row][col] === this.EMPTY || this.playerGrid[row][col] === this.NOTE)) {
                            this.playerGrid[row][col] = this.AUTO_CROSSED;
                            this.updateCellDisplay(row, col);
                        }
                    }
                    
                    this.updateRowHint(row);
                }
            }

            checkAndAutocrossCol(col) {
                let colComplete = true;
                
                for (let row = 0; row < this.rows; row++) {
                    const currentValue = this.playerGrid[row][col] === this.NOTE ? this.EMPTY : this.playerGrid[row][col];
                    
                    if (this.grid[row][col] === this.FILLED && currentValue !== this.FILLED) {
                        colComplete = false;
                        break;
                    }
                    if (this.grid[row][col] !== this.FILLED && currentValue === this.FILLED) {
                        colComplete = false;
                        break;
                    }
                }
                
                if (colComplete && !this.completedCols[col]) {
                    this.completedCols[col] = true;
                    
                    for (let row = 0; row < this.rows; row++) {
                        if (this.grid[row][col] !== this.FILLED && 
                            (this.playerGrid[row][col] === this.EMPTY || this.playerGrid[row][col] === this.NOTE)) {
                            this.playerGrid[row][col] = this.AUTO_CROSSED;
                            this.updateCellDisplay(row, col);
                        }
                    }
                    
                    this.updateColHint(col);
                }
            }

            checkAndAutocrossEdges() {
                // Zeilen pr√ºfen
                for (let row = 0; row < this.rows; row++) {
                    this.checkRowEdges(row);
                }
                
                // Spalten pr√ºfen
                for (let col = 0; col < this.cols; col++) {
                    this.checkColEdges(col);
                }
            }

            checkRowEdges(row) {
                const hints = this.rowHints[row];
                if (hints[0] === 0) return; // Leere Zeile
                
                const playerRow = this.playerGrid[row];
                
                // Links-Rand pr√ºfen
                this.checkLeftEdge(playerRow, hints, row);
                
                // Rechts-Rand pr√ºfen
                this.checkRightEdge(playerRow, hints, row);
            }

            checkLeftEdge(playerRow, hints, row) {
                const firstHint = hints[0];
                let consecutiveFilled = 0;
                
                // Z√§hle consecutive gef√ºllte Zellen von links
                for (let col = 0; col < this.cols; col++) {
                    if (playerRow[col] === this.FILLED) {
                        consecutiveFilled++;
                    } else {
                        break;
                    }
                }
                
                // Wenn wir genau die erste Hint-Anzahl erreicht haben
                if (consecutiveFilled === firstHint && consecutiveFilled < this.cols) {
                    const nextCol = consecutiveFilled;
                    // Auto-Cross setzen wenn das n√§chste Feld leer oder Note ist
                    if (playerRow[nextCol] === this.EMPTY || playerRow[nextCol] === this.NOTE) {
                        playerRow[nextCol] = this.AUTO_CROSSED;
                        this.updateCellDisplay(row, nextCol);
                    }
                }
            }

            checkRightEdge(playerRow, hints, row) {
                const lastHint = hints[hints.length - 1];
                let consecutiveFilled = 0;
                
                // Z√§hle consecutive gef√ºllte Zellen von rechts
                for (let col = this.cols - 1; col >= 0; col--) {
                    if (playerRow[col] === this.FILLED) {
                        consecutiveFilled++;
                    } else {
                        break;
                    }
                }
                
                // Wenn wir genau die letzte Hint-Anzahl erreicht haben
                if (consecutiveFilled === lastHint && consecutiveFilled < this.cols) {
                    const prevCol = this.cols - consecutiveFilled - 1;
                    // Auto-Cross setzen wenn das vorherige Feld leer oder Note ist
                    if (playerRow[prevCol] === this.EMPTY || playerRow[prevCol] === this.NOTE) {
                        playerRow[prevCol] = this.AUTO_CROSSED;
                        this.updateCellDisplay(row, prevCol);
                    }
                }
            }

            checkColEdges(col) {
                const hints = this.colHints[col];
                if (hints[0] === 0) return; // Leere Spalte
                
                // Spalten-Daten extrahieren
                const playerCol = [];
                for (let row = 0; row < this.rows; row++) {
                    playerCol.push(this.playerGrid[row][col]);
                }
                
                // Oben-Rand pr√ºfen
                this.checkTopEdge(playerCol, hints, col);
                
                // Unten-Rand pr√ºfen
                this.checkBottomEdge(playerCol, hints, col);
            }

            checkTopEdge(playerCol, hints, col) {
                const firstHint = hints[0];
                let consecutiveFilled = 0;
                
                // Z√§hle consecutive gef√ºllte Zellen von oben
                for (let row = 0; row < this.rows; row++) {
                    if (playerCol[row] === this.FILLED) {
                        consecutiveFilled++;
                    } else {
                        break;
                    }
                }
                
                // Wenn wir genau die erste Hint-Anzahl erreicht haben
                if (consecutiveFilled === firstHint && consecutiveFilled < this.rows) {
                    const nextRow = consecutiveFilled;
                    // Auto-Cross setzen wenn das n√§chste Feld leer oder Note ist
                    if (playerCol[nextRow] === this.EMPTY || playerCol[nextRow] === this.NOTE) {
                        this.playerGrid[nextRow][col] = this.AUTO_CROSSED;
                        this.updateCellDisplay(nextRow, col);
                    }
                }
            }

            checkBottomEdge(playerCol, hints, col) {
                const lastHint = hints[hints.length - 1];
                let consecutiveFilled = 0;
                
                // Z√§hle consecutive gef√ºllte Zellen von unten
                for (let row = this.rows - 1; row >= 0; row--) {
                    if (playerCol[row] === this.FILLED) {
                        consecutiveFilled++;
                    } else {
                        break;
                    }
                }
                
                // Wenn wir genau die letzte Hint-Anzahl erreicht haben
                if (consecutiveFilled === lastHint && consecutiveFilled < this.rows) {
                    const prevRow = this.rows - consecutiveFilled - 1;
                    // Auto-Cross setzen wenn das vorherige Feld leer oder Note ist
                    if (playerCol[prevRow] === this.EMPTY || playerCol[prevRow] === this.NOTE) {
                        this.playerGrid[prevRow][col] = this.AUTO_CROSSED;
                        this.updateCellDisplay(prevRow, col);
                    }
                }
            }

            updateRowHint(row) {
                const hints = document.getElementById('rowHints').children;
                if (hints[row]) {
                    hints[row].classList.toggle('completed', this.completedRows[row]);
                }
            }

            updateColHint(col) {
                const hints = document.getElementById('colHints').children;
                if (hints[col]) {
                    hints[col].classList.toggle('completed', this.completedCols[col]);
                }
            }

            checkWin() {
                if (this.gameLost) return false;
                
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const currentValue = this.playerGrid[row][col] === this.NOTE ? this.EMPTY : this.playerGrid[row][col];
                        
                        if (this.grid[row][col] === this.FILLED && currentValue !== this.FILLED) {
                            return false;
                        }
                        if (this.grid[row][col] !== this.FILLED && currentValue === this.FILLED) {
                            return false;
                        }
                    }
                }
                
                this.gameWon = true;
                this.stopTimer();
                this.calculateFinalScore();
                this.showResultDialog();
                return true;
            }

            calculateFinalScore() {
                const baseScore = this.points;
                const elapsedSeconds = this.elapsedTime / 1000;
                const totalCells = this.rows * this.cols;
                const expectedTime = totalCells * 0.5;
                
                // Effizienz-Bonus (weniger manuelle Markierungen)
                const markingCount = 0; // Vereinfacht f√ºr Web-Version
                const markingPercentage = markingCount / totalCells;
                const efficiencyBonus = Math.max(0, Math.floor(baseScore * 0.3 * (1 - markingPercentage)));
                
                // Zeit-Bonus
                let timeBonus = 0;
                if (elapsedSeconds < expectedTime) {
                    const timeFactor = Math.min(2.0, expectedTime / Math.max(1, elapsedSeconds));
                    timeBonus = Math.floor(baseScore * 0.5 * (timeFactor - 1));
                } else {
                    timeBonus = Math.floor(baseScore * 0.1 * Math.min(1.0, expectedTime / Math.max(1, elapsedSeconds)));
                }
                
                // Fehlerfreier Bonus
                const errorFreeBonus = this.errors === 0 ? Math.floor(baseScore * 0.2) : 0;
                
                this.finalScore = baseScore + efficiencyBonus + timeBonus + errorFreeBonus;
                this.points = this.finalScore;
                
                this.scoreDetails = {
                    baseScore,
                    efficiencyBonus,
                    timeBonus,
                    errorFreeBonus,
                    totalScore: this.finalScore
                };
            }

            checkGridForErrors() {
                let errorsCorrected = false;
                
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        // Falsche Kreuze entfernen
                        if ((this.playerGrid[row][col] === this.CROSSED || this.playerGrid[row][col] === this.AUTO_CROSSED) 
                            && this.grid[row][col] === this.FILLED) {
                            this.playerGrid[row][col] = this.EMPTY;
                            this.updateCellDisplay(row, col);
                            errorsCorrected = true;
                        }
                        
                        // Falsche F√ºllungen entfernen
                        if (this.playerGrid[row][col] === this.FILLED && this.grid[row][col] !== this.FILLED) {
                            this.playerGrid[row][col] = this.EMPTY;
                            this.updateCellDisplay(row, col);
                            errorsCorrected = true;
                        }
                    }
                }
                
                if (errorsCorrected && this.autoCrossMode) {
                    for (let row = 0; row < this.rows; row++) {
                        this.checkAndAutocrossRow(row);
                    }
                    for (let col = 0; col < this.cols; col++) {
                        this.checkAndAutocrossCol(col);
                    }
                }
                
                this.checkWin();
                this.updateUI();
            }

            startTimer() {
                this.timerRunning = true;
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    this.elapsedTime = Date.now() - this.startTime;
                    this.updateTimerDisplay();
                }, 1000);
            }

            stopTimer() {
                this.timerRunning = false;
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            resetTimer() {
                this.elapsedTime = 0;
                this.updateTimerDisplay();
            }

            updateTimerDisplay() {
                const seconds = Math.floor(this.elapsedTime / 1000);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                
                document.getElementById('timerDisplay').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            }

            updateUI() {
                document.getElementById('errorDisplay').textContent = 
                    `${this.localization.getString('errors')}: ${this.errors}/${this.maxErrors}`;
                document.getElementById('pointsDisplay').textContent = 
                    `${this.localization.getString('points')}: ${this.points}`;
                document.getElementById('comboDisplay').textContent = 
                    `${this.localization.getString('combo')}: x${this.comboCounter}`;

                // Mobile UI Updates
                if (document.getElementById('mobilePoints')) {
                    document.getElementById('mobilePoints').textContent = `${this.points} ${this.localization.getString('points')}`;
                }
                if (document.getElementById('mobileTimer')) {
                    document.getElementById('mobileTimer').textContent = document.getElementById('timerDisplay').textContent;
                }
            }

            showResultDialog() {
                const overlay = document.getElementById('resultOverlay');
                const dialog = document.getElementById('resultDialog');
                const title = document.getElementById('resultTitle');
                const details = document.getElementById('scoreDetails');
                const subtext = document.getElementById('resultSubtext');
                
                overlay.classList.remove('hidden');
                
                if (this.gameWon) {
                    dialog.className = 'result-dialog won';
                    title.className = 'result-title won';
                    
                    // Highscore speichern und pr√ºfen ob es ein neuer Rekord ist
                    const isNewRecord = this.highScoreManager.addScore(
                        this.currentSize, 
                        this.finalScore, 
                        this.elapsedTime, 
                        this.errors, 
                        this.loadedPredefinedImage
                    );
                    
                    // Titel basierend auf Rekord setzen
                    if (isNewRecord) {
                        title.innerHTML = this.localization.getString('newHighscore') + '<br>' + this.localization.getString('puzzleSolved');
                    } else {
                        title.textContent = this.localization.getString('puzzleSolved');
                    }
                    
                    // Score Details anzeigen
                    if (this.scoreDetails) {
                        details.innerHTML = `
                            <div class="score-line">${this.localization.getString('basePoints')}: ${this.scoreDetails.baseScore}</div>
                            <div class="score-line">${this.localization.getString('efficiencyBonus')}: +${this.scoreDetails.efficiencyBonus}</div>
                            <div class="score-line">${this.localization.getString('timeBonus')}: +${this.scoreDetails.timeBonus}</div>
                            ${this.scoreDetails.errorFreeBonus > 0 ? `<div class="score-line">${this.localization.getString('errorFreeBonus')}: +${this.scoreDetails.errorFreeBonus}</div>` : ''}
                            <div class="score-line"><strong>${this.localization.getString('totalScore')}: ${this.scoreDetails.totalScore}</strong></div>
                        `;
                    }
                    
                    subtext.textContent = this.localization.getString('newPuzzleHint');
                    
                    // Highscore Display aktualisieren
                    this.updateHighScoreDisplay();
                    
                } else {
                    dialog.className = 'result-dialog lost';
                    title.className = 'result-title lost';
                    title.textContent = this.localization.getString('tooManyErrors');
                    details.innerHTML = '';
                    subtext.textContent = this.localization.getString('restartHint');
                }
            }

            hideResultDialog() {
                document.getElementById('resultOverlay').classList.add('hidden');
            }


            setupLanguageButtons() {
                const deBut = document.getElementById('langDe');
                const enBut = document.getElementById('langEn');
                
                // Aktive Sprache markieren
                this.updateLanguageButtonStates();
                
                deBut.addEventListener('click', () => {
                    if (this.localization.currentLanguage !== 'de') {
                        this.localization.setLanguage('de');
                        this.updateLanguageButtonStates();
                        this.updateAllTexts();
                        this.updateHighScoreDisplay();
                    }
                });
                
                enBut.addEventListener('click', () => {
                    if (this.localization.currentLanguage !== 'en') {
                        this.localization.setLanguage('en');
                        this.updateLanguageButtonStates();
                        this.updateAllTexts();
                        this.updateHighScoreDisplay();
                    }
                });
            }

            setupHighscoreMenu() {
                const highscoreSection = document.getElementById('highscoreSection');
                const highscoreMenu = document.getElementById('highscoreMenu');
                
                // Men√º √∂ffnen/schlie√üen
                highscoreSection.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = highscoreMenu.style.display === 'block';
                    highscoreMenu.style.display = isVisible ? 'none' : 'block';
                });
                
                // Men√º schlie√üen bei Klick au√üerhalb
                document.addEventListener('click', () => {
                    highscoreMenu.style.display = 'none';
                });
                
                // Event-Listener f√ºr Men√º-Items
                this.updateHighscoreMenuTexts();
                
                // Highscore l√∂schen
                document.getElementById('clearHighscores').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(this.localization.getString('highscoreConfirmClear'))) {
                        this.highScoreManager.clearAllScores();
                        this.updateHighScoreDisplay();
                        highscoreMenu.style.display = 'none';
                    }
                });
                
                // Highscore exportieren
                document.getElementById('exportHighscores').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.exportHighscores();
                    highscoreMenu.style.display = 'none';
                });
                
                // Highscore importieren
                document.getElementById('importHighscores').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.importHighscores();
                    highscoreMenu.style.display = 'none';
                });
            }

            updateHighscoreMenuTexts() {
                document.getElementById('clearHighscores').textContent = this.localization.getString('highscoreMenuClear');
                document.getElementById('exportHighscores').textContent = this.localization.getString('highscoreMenuExport');
                document.getElementById('importHighscores').textContent = this.localization.getString('highscoreMenuImport');
            }

            exportHighscores() {
                const highscores = this.highScoreManager.loadFromStorage();
                const dataStr = JSON.stringify(highscores, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = 'nonogram_highscores.json';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            importHighscores() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.style.display = 'none';
                
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const importedData = JSON.parse(e.target.result);
                                
                                // Validierung der Daten
                                if (typeof importedData === 'object' && importedData !== null) {
                                    // Best√§tigung vor Import
                                    if (confirm(this.localization.getString('highscoreConfirmImport'))) {
                                        this.highScoreManager.saveToStorage(importedData);
                                        this.updateHighScoreDisplay();
                                        alert(this.localization.getString('highscoreImportSuccess'));
                                    }
                                } else {
                                    throw new Error('Invalid data format');
                                }
                            } catch (error) {
                                alert(this.localization.getString('highscoreImportError'));
                            }
                        };
                        reader.readAsText(file);
                    }
                    document.body.removeChild(input);
                });
                
                document.body.appendChild(input);
                input.click();
            }

            updateLanguageButtonStates() {
                const deBut = document.getElementById('langDe');
                const enBut = document.getElementById('langEn');
                
                deBut.classList.toggle('active', this.localization.currentLanguage === 'de');
                enBut.classList.toggle('active', this.localization.currentLanguage === 'en');
            }

            updateAllTexts() {
                document.querySelector('.title').textContent = this.localization.getString('title');
                
                // Alle control-labels aktualisieren
                const controlLabels = document.querySelectorAll('.control-label');
                controlLabels[0].textContent = this.localization.getString('gridSize'); // Spielfeldgr√∂√üe
                controlLabels[1].textContent = this.localization.getString('currentTool'); // Aktuelles Werkzeug
                controlLabels[2].textContent = this.localization.getString('colorPicker'); // Farbw√§hler
                
                // Dropdown-Optionen aktualisieren
                const options = document.querySelectorAll('.dropdown-option span:first-child');
                const sizes = ['easy', 'medium', 'hard', 'rectangular', 'rectangular', 'rectangular', 'rectangular', 'rectangular'];
                const numbers = ['5x5', '10x10', '15x15', '5x10', '10x15', '10x5', '15x10', '20x15'];
                
                options.forEach((option, index) => {
                    if (index < 3) {
                        option.textContent = `${this.localization.getString(sizes[index])} (${numbers[index]})`;
                    } else {
                        option.textContent = `${this.localization.getString('rectangular')} ${index-2} (${numbers[index]})`;
                    }
                });
                
                // Dropdown Selected Text basierend auf aktueller Gr√∂√üe aktualisieren
                this.updateDropdownSelectedText();

                // Highscore-Men√º lokalisieren
                this.updateHighscoreMenuTexts();
                
                // Timer Label
                document.querySelector('.timer-section div:first-child strong').textContent = this.localization.getString('time') + ':';

                // Highscore Label
                document.querySelector('.highscore-section-mini div:first-child strong').textContent = 
                    this.localization.currentLanguage === 'de' ? 'Highscore:' : 'Highscore:';
                
                // Initiale UI-Texte setzen
                this.updateUI(); // Dies wird die √ºbersetzten Texte f√ºr Fehler, etc. setzen
                
                // Auto-Cross Status setzen
                document.getElementById('autoCrossStatus').textContent = 
                    this.autoCrossMode ? this.localization.getString('autoCrossOn') : this.localization.getString('autoCrossOff');
                
                // Aktuelle Farbe aktualisieren
                const colorText = this.localization.getColorName(this.selectedColor);
                document.getElementById('currentColorText').textContent = 
                    `${this.localization.getString('currentColor')}: ${colorText}`;
                
                // Tool-Namen aktualisieren
                this.updateToolDisplay();

                // Highscore-Men√º lokalisieren
                document.getElementById('clearHighscores').textContent = this.localization.getString('highscoreMenuClear');
                document.getElementById('exportHighscores').textContent = this.localization.getString('highscoreMenuExport');
                document.getElementById('importHighscores').textContent = this.localization.getString('highscoreMenuImport');
                
                // Instructions aktualisieren
                const instructions = document.querySelector('.instructions');
                if (this.localization.currentLanguage === 'de') {
                    instructions.innerHTML = `
                        <strong>${this.localization.getString('controls')}</strong><br>
                        T: Zwischen Stift/Durchstreichen wechseln<br>
                        H/O: Notiz-Werkzeug aktivieren/deaktivieren<br>
                        A: Auto-Durchstreichen ein/aus<br>
                        C: Raster auf Fehler pr√ºfen<br>
                        +/-: Zoomen<br>
                        Pfeiltasten: Spielfeld verschieben<br>
                        0: Zoom/Position zur√ºcksetzen<br>
                        Linksklick/Ziehen: Zelle markieren<br>
                        Rechtsklick: Alternative Markierung<br>
                        R: Puzzle zur√ºcksetzen<br>
                        N: Neues Puzzle<br>
                        E: Neues Bildpuzzle
                    `;
                } else {
                    instructions.innerHTML = `
                        <strong>${this.localization.getString('controls')}</strong><br>
                        T: Toggle Pen/Cross tool<br>
                        H/O: Toggle Note tool<br>
                        A: Toggle Auto-Cross<br>
                        C: Check grid for errors<br>
                        +/-: Zoom in/out<br>
                        Arrow keys: Pan grid<br>
                        0: Reset zoom/position<br>
                        Left click/drag: Mark cell<br>
                        Right click: Alternative marking<br>
                        R: Reset puzzle<br>
                        N: New puzzle<br>
                        E: New image puzzle
                    `;
                }
            }

            updateDropdownSelectedText() {
                const sizeMap = {
                    "5,5": { key: 'easy', size: '5x5' },
                    "10,10": { key: 'medium', size: '10x10' },
                    "15,15": { key: 'hard', size: '15x15' },
                    "5,10": { key: 'rectangular', size: '5x10', num: 1 },
                    "10,15": { key: 'rectangular', size: '10x15', num: 2 },
                    "10,5": { key: 'rectangular', size: '10x5', num: 3 },
                    "15,10": { key: 'rectangular', size: '15x10', num: 4 },
                    "20,15": { key: 'rectangular', size: '20x15', num: 5 }
                };
                
                const mapping = sizeMap[this.currentSize];
                if (mapping) {
                    let text;
                    if (mapping.num) {
                        text = `${this.localization.getString(mapping.key)} ${mapping.num} (${mapping.size})`;
                    } else {
                        text = `${this.localization.getString(mapping.key)} (${mapping.size})`;
                    }
                    document.getElementById('dropdownSelected').querySelector('span').textContent = text;
                }
            }

            updateHighScoreDisplay() {
                const bestScore = this.highScoreManager.getHighScores(this.currentSize, this.loadedPredefinedImage);
                document.getElementById('highscoreValue').textContent = bestScore;
            }

            zoomIn() {
                if (this.zoomLevel < this.maxZoom) {
                    this.zoomLevel = Math.min(this.maxZoom, this.zoomLevel + this.zoomStep);
                    this.applyTransform();
                    this.showZoomInfo();
                }
            }

            zoomOut() {
                if (this.zoomLevel > this.minZoom) {
                    this.zoomLevel = Math.max(this.minZoom, this.zoomLevel - this.zoomStep);
                    this.applyTransform();
                    this.showZoomInfo();
                }
            }

            panUp() {
                this.panY += this.panStep;
                this.applyTransform();
            }

            panDown() {
                this.panY -= this.panStep;
                this.applyTransform();
            }

            panLeft() {
                this.panX += this.panStep;
                this.applyTransform();
            }

            panRight() {
                this.panX -= this.panStep;
                this.applyTransform();
            }

            resetZoomAndPan() {
                this.zoomLevel = 1.0;
                this.panX = 0;
                this.panY = 0;
                this.applyTransform();
                this.showZoomInfo();
            }

            applyTransform() {
                const container = document.getElementById('gridContainer');
                container.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoomLevel})`;
            }

            showZoomInfo() {
                const zoomInfo = document.getElementById('zoomInfo');
                zoomInfo.textContent = `Zoom: ${Math.round(this.zoomLevel * 100)}%`;
                zoomInfo.classList.add('visible');
                
                // Auto-hide nach 2 Sekunden
                if (this.zoomInfoTimeout) {
                    clearTimeout(this.zoomInfoTimeout);
                }
                this.zoomInfoTimeout = setTimeout(() => {
                    zoomInfo.classList.remove('visible');
                }, 2000);
            }


        }

        // Event-Listener f√ºr Maus-Events auf Document-Level
        document.addEventListener('mouseup', (e) => {
            if (window.game) {
                window.game.isDragging = false;
                window.game.lastCell = null;
                window.game.dragValue = null;
            }
        });

        // Zus√§tzliche Sicherheit f√ºr den Fall, dass die Maus das Spielfeld verl√§sst
        document.addEventListener('mouseleave', (e) => {
            if (window.game) {
                window.game.isDragging = false;
                window.game.lastCell = null;
                window.game.dragValue = null;
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            // Spiel initialisieren
            window.game = new NonogrammGame();
            
            // Debug-Funktionen f√ºr Konsole verf√ºgbar machen
            window.debugHighscores = () => window.game.highScoreManager.debugShowAllScores();
            window.clearHighscores = () => {
                window.game.highScoreManager.clearAllScores();
                window.game.updateHighScoreDisplay();
            };
            
            // Zus√§tzliche Event-Listener nach der Initialisierung
            const gameGrid = document.getElementById('gameGrid');
            if (gameGrid) {
                gameGrid.addEventListener('mouseleave', (e) => {
                    if (window.game) {
                        window.game.isDragging = false;
                        window.game.lastCell = null;
                        window.game.dragValue = null;
                    }
                });
            }
            
            // Mausrad-Zoom Support (optional)
            if (gameGrid) {
                gameGrid.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) { // Nur mit Ctrl/Cmd gedr√ºckt
                        e.preventDefault();
                        if (e.deltaY < 0) {
                            window.game.zoomIn();
                        } else {
                            window.game.zoomOut();
                        }
                    }
                });
            }
        });

        // Diese Event-Listener bleiben au√üerhalb, da sie auf document h√∂ren:
        document.addEventListener('mouseup', (e) => {
            if (window.game) {
                window.game.isDragging = false;
                window.game.lastCell = null;
                window.game.dragValue = null;
            }
        });

        document.addEventListener('mouseleave', (e) => {
            if (window.game) {
                window.game.isDragging = false;
                window.game.lastCell = null;
                window.game.dragValue = null;
            }
        });

    </script>


    <!-- Mobile Bottom Bar -->
    <div class="mobile-bottom-bar">
        <div class="mobile-tools">
            <div class="mobile-tool-item active" id="mobileToolPen" data-tool="pen">
                <div style="width: 20px; height: 20px; background-color: #323246; border-radius: 2px;"></div>
            </div>
            <div class="mobile-tool-item" id="mobileToolCross" data-tool="cross">
                <div style="position: relative; width: 20px; height: 20px;">
                    <div style="position: absolute; width: 16px; height: 2px; background: #dc3232; transform: rotate(45deg); top: 9px; left: 2px;"></div>
                    <div style="position: absolute; width: 16px; height: 2px; background: #dc3232; transform: rotate(-45deg); top: 9px; left: 2px;"></div>
                </div>
            </div>
            <div class="mobile-tool-item" id="mobileToolNote" data-tool="note">
                <div style="width: 8px; height: 8px; background: #8080c8; border-radius: 50%;"></div>
            </div>
        </div>
        
        <div class="mobile-info">
            <div id="mobilePoints">0 Punkte</div>
            <div id="mobileTimer">00:00</div>
        </div>
        
        <div class="mobile-size-dropdown" id="mobileSizeDropdown">
            <span id="mobileSizeText">10x10</span>
            <div class="mobile-size-options" id="mobileSizeOptions">
                <div class="mobile-size-option" data-size="5,5">5x5</div>
                <div class="mobile-size-option" data-size="10,10">10x10</div>
                <div class="mobile-size-option" data-size="15,15">15x15</div>
                <div class="mobile-size-option" data-size="5,10">5x10</div>
                <div class="mobile-size-option" data-size="10,15">10x15</div>
                <div class="mobile-size-option" data-size="10,5">10x5</div>
                <div class="mobile-size-option" data-size="15,10">15x10</div>
                <div class="mobile-size-option" data-size="20,15">20x15</div>
            </div>
        </div>
    </div>

    <div class="result-overlay hidden" id="resultOverlay">

</body>
</html>
